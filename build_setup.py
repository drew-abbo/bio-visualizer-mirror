#!/usr/bin/env python3

HELP = """
This is nasty but it's the nicest solution I could come up with. Run this before
you try and run `cargo build`. Follow the instructions (possibly re-running it a
few times) until it says you're done.

The `-y` or `-n` flags can be provided to auto-accept or auto-deny any prompts
for user confirmation.

On Windows, this script:
- Ensures you have the proper C compiler dependencies to build ffmpeg-next's
  rust bindings.
- Ensures you have FFmpeg shared libraries/headers (with an option to download
  them automatically).
- Generates a `.cargo/config.toml` that sets all the needed environment
  variables to build ffmpeg-next.

On MacOS, this script:
- Ensures you have Homebrew installed (with an option to install it
  automatically).
- Uses Homebrew to ensure you have the required ffmpeg and pkg-config packages
  installed.

The compiled executable will depend on shared library files (e.g. dll/dylib
files).
""".rstrip()

import json
import os
import platform
import re
import shutil
import sys
import tempfile
import urllib.request
import typing
from typing import Any, Union, Optional

import build_util.log as log
import build_util.sh as sh
import build_util.user as user


def parse_args() -> None:
    """
    Parses command line arguments.
    """

    ARG_0 = sys.argv[0]
    USAGE = f"""
Usage:
    {ARG_0} [-y|-n]
    {ARG_0} --help
""".rstrip()

    auto_confirm = None

    for arg in sys.argv[1:]:
        if arg in ("-h", "--help", "help", "/h", "/?", "h", "?"):
            print(f"{USAGE}{HELP}")
            sys.exit(int(len(sys.argv) != 2))

        if arg in ("-y", "-n"):
            if auto_confirm:
                if arg[1] == auto_confirm:
                    log.fatal(f"Repeat argument `{arg}`." + USAGE)
                else:
                    log.fatal(
                        f"Arguments `{arg}` and `-{auto_confirm}`"
                        + " are incompatible."
                        + USAGE
                    )
            auto_confirm = arg[1]
            user.set_confirm_auto_answer(auto_confirm)

        else:
            log.fatal(f"Unknown argument `{arg}`." + USAGE)


def create_cargo_config(contents: str) -> None:
    """
    Create a `.cargo/config.toml` file.
    """

    path = (
        ".cargo\\config.toml"
        if platform.system() == "Windows"
        else ".cargo/config.toml"
    )

    if os.path.exists(path) and not user.confirm(
        f"A `{path}` file already exists. Overwrite?"
    ):
        log.fatal(f"Failed to create `{path}`.")
    else:
        os.makedirs(".cargo", exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write("# Generated by `build_setup.py`.\n" + contents)

    log.info(f"Cargo config generated (`{path}`).")


def windows() -> None:
    """
    Handles build setup for Windows builds.
    """

    if sh.get_supported_arch() != "x86_64":
        log.fatal("Windows builds currently only support x86_64.")

    program_files_x86 = os.environ.get("ProgramFiles(x86)")
    program_files = os.environ.get("ProgramFiles")
    if program_files_x86 is None or program_files is None:
        log.fatal("Coldn't find program files.")

    vs_installer_dir = (
        f"{program_files_x86}\\Microsoft Visual Studio\\Installer"
    )

    sh.ensure_path_exists(
        vs_installer_dir,
        help_msg="You likely don't have `Visual Studio Installer`"
        + " on your system. Please install it from here:\n"
        + "https://visualstudio.microsoft.com/",
    )

    # `vswhere` lets us find where a specific version is installed.
    sh.ensure_path_exists(f"{vs_installer_dir}\\vswhere.exe")
    try:
        vs_installation_path = sh.run_cmd(
            f"{vs_installer_dir}\\vswhere.exe",
            "-property",
            "installationPath",
            "-version",
            "[17.0, 19.0)",  # Only Visual Studio 2022 or 2026.
            "-latest",
            non_fatal=True,
        )
    except sh.CmdException:
        log.fatal("Couldn't find Visual Studio (2022 or 2026).")
    log.info("MSVC found.")

    # Collect a list of all Visual Studio components that are installed.
    def get_installed_vs_components() -> list[str]:
        log.info("Exporting installed Visual Studio components...")

        # We'll use `vs_installer` to query installed components. The result
        # will be written to a JSON config file we can read.

        temp_vs_installer_config_path = (
            f"{tempfile.gettempdir()}\\config.vsconfig"
        )

        vs_installer_err_msg = (
            "Failed to export installed Visual Studio components."
            + " Make sure the Visual Studio Installer isn't already runnning."
        )

        try:
            sh.run_cmd(
                f"{vs_installer_dir}\\vs_installer.exe",
                "--installPath",
                vs_installation_path,
                "export",
                "--config",
                temp_vs_installer_config_path,
                "--quiet",
                "--noUpdateInstaller",
                non_fatal=True,
            )
        except sh.CmdException as e:
            log.fatal(f"{e}\n{vs_installer_err_msg}")

        try:
            with open(temp_vs_installer_config_path) as f:
                installed_components = json.load(f)["components"]
            os.remove(temp_vs_installer_config_path)
        except FileNotFoundError:
            log.fatal(vs_installer_err_msg)

        log.info("Installed Visual Studio components exported.")
        return installed_components

    installed_vs_components = get_installed_vs_components()

    # Ensures we have a required Visual Studio component installed.
    def ensure_vs_component_is_installed(
        component_name: str, component_regex: str
    ) -> None:
        component_is_installed = any(
            re.fullmatch(component_regex, installed_component) is not None
            for installed_component in installed_vs_components
        )

        if not component_is_installed:
            sh.start_cmd(f"{vs_installer_dir}\\vs_installer.exe")
            log.fatal(
                f"Missing the `{component_name}` component."
                + " Please use the Visual Studio Installer to install it.\n"
                + "Trying to opening the Visual Studio Installer..."
            )

        log.info(
            f"The `{component_name}` Visual Studio component is installed."
        )

    # At a minimum, rust needs C++ build tools and a Windows 11 SDK.
    ensure_vs_component_is_installed(
        "C++ x64/x86 build tools (Latest)",
        r"Microsoft\.VisualStudio\.Component\.VC\.Tools\..*",
    )
    ensure_vs_component_is_installed(
        "Windows 11 SDK",
        r"Microsoft\.VisualStudio\.Component\.Windows11SDK\..*",
    )

    # `ffmpeg-next` uses `bindgen` which requires `libclang` to generate rust
    # bindings. We get that from this component.
    ensure_vs_component_is_installed(
        "C++ Clang Compiler for Windows",
        r"Microsoft\.VisualStudio\.Component\.VC\.Llvm\.Clang",
    )

    # Finds the `libclang` DLL.
    def get_libclang_path() -> str:
        # `libclang` needs to be installed for FFmpeg-next to be able to create
        # rust bindings.
        libclang_path = f"{vs_installation_path}\\VC\\Tools\\LLVM\\x64\\bin"
        sh.ensure_path_exists(f"{libclang_path}\\libclang.dll")
        log.info("Found `libclang`.")

        return libclang_path

    # Try and ensure we're using the right header files for generating rust
    # bindings for FFmpeg.
    def try_to_get_clang_include_dir() -> Optional[str]:
        try:
            clang_dir = (
                f"{vs_installation_path}\\VC\\Tools\\LLVM\\x64\\lib\\clang"
            )

            newest_clang_version = sorted(
                version
                for version in os.listdir(clang_dir)
                if os.path.isdir(os.path.join(clang_dir, version))
            )[-1]

            clang_include_dir = f"{clang_dir}\\{newest_clang_version}\\include"
            sh.ensure_path_exists(clang_include_dir, non_fatal=True)

            log.info("Found Clang include directory.")
        except (FileNotFoundError, IndexError, sh.DoesntExistException):
            log.warning(
                "Failed to find Clang include directory. Compilation may fail."
            )
            clang_include_dir = None

        return clang_include_dir

    # Make sure we have FFmpeg installed in the project directory.
    def get_ffmpeg_dir() -> str:
        FFMPEG_ZIP_PATH = ".\\ffmpeg.7z"
        FFMPEG_DIR = ".\\ffmpeg"

        def download_ffmpeg_zip() -> None:
            FFMPEG_DOWNLOAD_URL = "https://www.gyan.dev/ffmpeg/builds/packages/ffmpeg-8.0.1-full_build-shared.7z"

            MANUAL_INSTALL_MSG = (
                "You can still manually install.\n"
                + "Please rerun this script after downloading and extracting"
                + f" FFmpeg to `{FFMPEG_DIR}`"
                + f" from the link below (or anywhere):\n{FFMPEG_DOWNLOAD_URL}"
            )

            if not user.confirm(
                "You don't have FFmpeg installed locally yet."
                + " Do you want to download FFmpeg from the internet now?"
            ):
                log.fatal(f"Skipping auto-download. {MANUAL_INSTALL_MSG}")

            log.info(
                "Installing FFmpeg. This may take a while... ",
                end="",
                flush=True,
            )

            try:
                urllib.request.urlretrieve(FFMPEG_DOWNLOAD_URL, FFMPEG_ZIP_PATH)
            except KeyboardInterrupt:
                try:
                    os.remove(FFMPEG_ZIP_PATH)
                except:
                    pass
                log.warning(f"\nDownload cancelled. {MANUAL_INSTALL_MSG}")
                raise
            except Exception:
                log.fatal(f"\nDownload failed. {MANUAL_INSTALL_MSG}")
            print("Done.")
            log.info("FFmpeg zip file downloaded.")

        def get_7z_cmd() -> Optional[str]:
            log.info("Checking for 7z utility.")
            sevenzip_cmd: Optional[str] = None
            for cmd in (
                "7z",
                "7z.exe",
                f"{program_files}\\7-Zip\\7z.exe",
                f"{program_files_x86}\\7-Zip\\7z.exe",
            ):
                try:
                    sh.ensure_cmd_exists(cmd, non_fatal=True)
                except sh.DoesntExistException:
                    continue
                else:
                    sevenzip_cmd = cmd
                    break

            if sevenzip_cmd is not None:
                log.info("7z utility found.")
            else:
                log.info("7z utility not found.")

            return sevenzip_cmd

        def extract_ffmpeg() -> None:
            if (sevenzip_cmd := get_7z_cmd()) is not None:
                log.info("Auto-extracting FFmpeg zip file with 7z utility.")
                try:
                    sh.run_cmd(
                        sevenzip_cmd,
                        "x",
                        FFMPEG_ZIP_PATH,
                        f"-o{FFMPEG_DIR}",
                    )
                except:
                    log.warning("Failed to extract with 7z utility.")
                else:
                    return

            # Without the 7z command utility we can't extract it for the
            # user since the download is a 7z file for some reason and
            # there's no default way to extract a 7z file on windows without
            # using the file explorer UI.

            log.info("Attempting to open file explorer on FFmpeg zip file.")
            sh.start_cmd(
                "explorer",
                "/select,",
                f"{os.path.abspath(FFMPEG_ZIP_PATH)}",
            )
            user.action_needed(
                f"Please extract `{FFMPEG_ZIP_PATH}`" + f" to `{FFMPEG_DIR}`.",
            )

            ffmpeg_dir_exists = os.path.exists(FFMPEG_DIR)
            if not ffmpeg_dir_exists:
                log.fatal("The FFmpeg directory wasn't extracted.")

        def un_nest_ffmpeg_dir() -> None:
            try:
                ffmpeg_dir_list = os.listdir(FFMPEG_DIR)
            except:
                log.fatal("Failed to check FFmpeg directory contents.")

            if len(ffmpeg_dir_list) != 1 or not user.confirm(
                "FFmpeg directory contains only 1 subfolder"
                + f" `{ffmpeg_dir_list[0]}`."
                + " Attempt auto-fix?"
            ):
                return

            try:
                tmp_location = tempfile.gettempdir()
                shutil.move(FFMPEG_DIR, tmp_location)
                shutil.move(f"{tmp_location}\\{ffmpeg_dir_list[0]}", FFMPEG_DIR)
                os.rmdir(tmp_location)
            except:
                log.warning("FFmpeg directory structure fix failed.")
                if not user.confirm("Auto-fix failed. Continue anyway?"):
                    log.fatal("Not continuing.")
            else:
                log.info("FFmpeg directory structure fix attempted.")

        if not os.path.exists(FFMPEG_DIR):
            if not os.path.exists(FFMPEG_ZIP_PATH):
                download_ffmpeg_zip()
            extract_ffmpeg()

        # If there's only 1 item in the FFmpeg directory, it's probably because
        # when it was extracted the useful stuff was left inside a nested
        # directory. If we detect this we can pull all of that out into the root
        # `ffmpeg` directory (but we still ask first).
        un_nest_ffmpeg_dir()

        sh.ensure_path_exists(f"{FFMPEG_DIR}\\include")
        sh.ensure_path_exists(f"{FFMPEG_DIR}\\lib")
        sh.ensure_path_exists(f"{FFMPEG_DIR}\\bin")
        log.info("FFmpeg found locally.")

        if os.path.exists(FFMPEG_ZIP_PATH) and user.confirm(
            "Auto-downloaded FFmpeg zip file no longer needed."
            + f" Would you like to remove it (`{FFMPEG_ZIP_PATH}`)?",
        ):
            os.remove(FFMPEG_ZIP_PATH)

        return os.path.abspath(FFMPEG_DIR)

    libclang_path = get_libclang_path()
    clang_include_dir = try_to_get_clang_include_dir()
    ffmpeg_dir = get_ffmpeg_dir()

    def to_unix_path(path: str) -> str:
        return path.replace("\\", "/")

    # We need to set `LIBCLANG_PATH` so that `ffmpeg-next` can build its
    # bindings.
    # We also need to set `FFMPEG_DIR` so that `ffmpeg-next` has FFmpeg's actual
    # lib and include files. This is required because you can only dynamically
    # link with FFmpeg.
    # See https://github.com/zmwangx/rust-ffmpeg/wiki/Notes-on-building
    cargo_config = (
        "[env]\n"
        + f'LIBCLANG_PATH = "{to_unix_path(libclang_path)}"\n'
        + f'FFMPEG_DIR = "{to_unix_path(ffmpeg_dir)}"\n'
    )
    if clang_include_dir is not None:
        # If we found Clang's include directory we'll explicitly pass it to
        # `bindgen` (the library `ffmpeg-next` uses to generate rust bindings)
        # so that it doesn't get confused and try to build using mingw headers
        # or something else weird.
        cargo_config += (
            "BINDGEN_EXTRA_CLANG_ARGS = "
            + f'"-I{to_unix_path(clang_include_dir)}"\n'
        )

    create_cargo_config(cargo_config)

    sh.run_cmd("cargo", "clean")
    log.info("Build directory cleaned.")


def mac_os() -> None:
    """
    Handles build setup for MacOS builds.
    """

    arch = sh.get_supported_arch()
    if arch is None:
        log.fatal("MacOS builds only support x86_64 and arm64")

    def ensure_brew_is_installed() -> None:
        try:
            sh.ensure_cmd_exists("brew", non_fatal=True)
        except sh.DoesntExistException:
            if not user.confirm(
                "You do not have the Homebrew package manager installed."
                + " Start Homebrew install? (you'll need to be a system admin)"
            ):
                log.fatal("Homebrew is required.")

            # This comes from the download instructions here: https://brew.sh/
            sh.run_cmd(
                '/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"',
                shell=True,
            )
            sh.ensure_cmd_exists("brew")

        log.info("Found Homebrew package manager.")

    last_installed_pkgs: Optional[list[dict[str, Any]]] = None

    def is_installed_with_brew(
        pkg_name: str, ask_to_install: bool = False
    ) -> bool:
        nonlocal last_installed_pkgs
        if last_installed_pkgs is None:
            last_installed_pkgs = typing.cast(
                list[dict[str, Any]],
                json.loads(
                    sh.run_cmd(
                        "brew",
                        "info",
                        "--installed",
                        "--json",
                        show_output=False,
                    )
                ),
            )
        installed_pkgs = last_installed_pkgs

        def names_from_pkg_dict(pkg_dict: dict[str, Any]) -> list[str]:
            ret: list[str] = []
            for key in ("name", "full_name", "oldnames", "aliases"):
                val = pkg_dict.get(key)
                if isinstance(val, str):
                    ret.append(val)
                elif isinstance(val, list):
                    ret.extend(
                        sub_val
                        for sub_val in typing.cast(list[Union[str, Any]], val)
                        if isinstance(sub_val, str)
                    )
            return ret

        is_already_installed = any(
            pkg_name in names_from_pkg_dict(pkg_dict)
            for pkg_dict in installed_pkgs
        )

        if is_already_installed or not ask_to_install:
            return is_already_installed

        if not user.confirm(
            f"It doesn't look like you have `{pkg_name}` installed."
            + " Install with Homebrew?"
        ):
            return False

        log.info(
            f"Installing `{pkg_name}` with Homebrew."
            + " This can take a very long time."
        )
        last_installed_pkgs = None
        sh.run_cmd("brew", "install", pkg_name)
        return True

    ensure_brew_is_installed()
    if not is_installed_with_brew("ffmpeg@8", ask_to_install=True):
        log.warning("Continuing without installing FFmpeg (8).")
    if not is_installed_with_brew("pkg-config", ask_to_install=True):
        log.warning("Continuing without installing `pkg-config`.")

    sh.run_cmd("cargo", "clean")
    log.info("Build directory cleaned.")


def main() -> None:
    parse_args()

    sh.ensure_cmd_exists("cargo")

    system = platform.system().lower()
    if system == "windows":
        windows()
    elif system == "darwin":  # MacOS
        mac_os()
    elif system == "linux":
        log.fatal("unimplemented")
    else:
        log.fatal(f"Unsupported system: `{system}`")

    log.success("Build setup complete.")


if __name__ == "__main__":
    sh.catch_stop_signal(main)
