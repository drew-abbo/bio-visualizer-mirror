//! Declares the [Uid] type, a type that [super::Frame] depends on.

use std::cell::{OnceCell, RefCell};
use std::sync::atomic::{AtomicUsize, Ordering};

/// A unique identifier for a [Frame](super::Frame). For the
/// duration of a [Frame](super::Frame)'s lifetime, no other frames will have an
/// equal [Uid].
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Uid {
    major_id: usize,
    minor_id: usize,
}

impl Uid {
    /// Generates a new [Uid].
    ///
    /// The first UID generated on a thread requires some synchronization (an
    /// atomic fetch-add). All subsequent UIDs will be able to be generated
    /// entirely thread-locally.
    pub fn generate_new() -> Self {
        // `Uid`s hold a major ID (`major_id`) and a minor ID (`minor_id`).
        //
        // The major ID uniquely identifies the thread that the `Uid` came from
        // (e.g. if `major_id == 6`, the `Uid` was generated by the 6th thread
        // to generate a `Uid`).
        //
        // The minor ID uniquely identifies a `Uid` relative to its thread (e.g.
        // if `major_id == 6` and `minor_id == 7`, the `Uid` is the 7th `Uid`
        // to be generated by the 6th thread to generate a `Uid`).
        //
        // Doing it like this means that a thread generating a `Uid` only needs
        // to synchronize with other threads for the first `Uid` it generates
        // (fetching and incrementing the global `NEXT_THREAD_ID` value). It can
        // then use a thread local cache to store its major ID (`MAJOR_ID`) and
        // a thread local counter for the minor ID (`NEXT_MINOR_ID`) so that it
        // never has to synchronize again.

        thread_local! {
            static MAJOR_ID: OnceCell<usize> = const { OnceCell::new() };
            static NEXT_MINOR_ID: RefCell<usize> = const { RefCell::new(0) };
        }
        static NEXT_MAJOR_ID: AtomicUsize = const { AtomicUsize::new(0) };

        Uid {
            major_id: MAJOR_ID.with(|thread_id| {
                *thread_id.get_or_init(|| NEXT_MAJOR_ID.fetch_add(1, Ordering::SeqCst))
            }),

            minor_id: NEXT_MINOR_ID.with_borrow_mut(|next_frame_id| {
                let frame_id = *next_frame_id;
                *next_frame_id += 1;
                frame_id
            }),
        }
    }
}
